
* Part 1: Classes, Loops, Mouse Input, Simple Overlap Checking
** for loop: draw rectangles
** nested for loop
** goal: move them around
can't use a formula anymore
** Bounds class
*** constructor
*** draw()
** show it still works
** now let's do something on mousePressed
*** store mHandX, mHandY
*** could just mess around with x and y in here, but better is to create method
*** x2 and y2
*** containsPoint
** now let's drag them around
*** mOffX, mOffY
** now show overlap
*** overlaps(Bounds)
*** exercise: contains(Bounds)
** problems with this:
- slower and slower as you add more objects


* Part 2: Bullets
** intro:
we're making sketch invaders (show)
so far we have overlap detection (show)
in this episode: fire with mouse to shoot at frame-animated invaders

** start with overlap detection example
get rid of mousereleased / mouse dragged, boxinhand, and the offsets

leave mousepressed, but make it empty

void mousePressed()
{
    // TODO : fire new Bullet(mouseX, mouseY);
}


** what is a bullet?

    class Bullet extends Rectangle
    {
        Bullet(float x, float y)
        {
            super(x, y, 10, 20);
        }
    }

** extract Rectangle from Square

    run to test



** let's start with 10 bullets.
final int kBulletW = 10;
final int kBulletH = 20;

        super(x, y, kBulletW, kBulletH);

    for (int i = 0; i < kBulletCount; ++i)
    {
        mBullets[i] = new Bullet(kBulletW * i, height - kBulletH);
    }

** now to draw them
let's ignore the collision detection code up here for the time being,
and just draw our bullets. We'll make them gold.

    fill(#FFCC33);
    for (int i = 0; i < kBulletCount; ++i)
    {
        mBullets[i].render();
    }

** so let's fire a bullet

well... first we have to decide which one. let's take the first one for now.

void mousePressed()
{
    Bullet b = mBullets[0];
    b.x = mouseX;
    b.y = height - kBulletH * 2;
}

** now let's make it move.
two parts: we want it to move, but we only want the one's we've fired to move.

in Bullet:
    boolean alive = false;
    
    float dy = -1;
    float dx = 0;

    void update()
    {
        if (this.alive)
        {
            y += dy;
            x += dx;
        }
    }
    

now we need to make it alive when we fire it. let's make a
new method for that.

    void fire(float x, float y)
    {
        this.x = x;
        this.y = y;
        this.alive = true;
    }


and now we update mousePressed() to use the new interface:

void mousePressed()
{
    Bullet b = mBullets[0];
    b.fire(mouseX, height - kBulletH * 2);
}


at top of loop in draw:

    for (int i = 0; i < kBulletCount; ++i)
    {
        mBullets[i].update();
    }



** okay, so that's too slow, and worse, it resets each time we fire

// extract method:
Bullet nextBullet()
{
    return mBullets[0];
}


Bullet nextBullet()
{
    for (int i = 0; i < kBulletCount; ++i)
    {
        if (! mBullets[i].alive)
        {
            return mBullets[i];
        }
    }
    // always return a bullet so we don't have to check for null
    return mBullets[0];
}



** recycling
Bounds SCREEN_BOUNDS;

SCREEN_BOUNDS = new Bounds(0, 0, width, height);


            if (! bullet.overlaps(SCREEN_BOUNDS))
            {
                bullet.alive = false;
            }



we could put this in Bullet.update() but to me
t's really more about the interaction between
objects, and not the object itself.

so let's make a game-wide update()


** extract update() and render() from draw()


we end up with this:

void update()
{
    for (int i = 0; i < kBulletCount; ++i)
    {
        Bullet b = mBullets[i];
        if (b.overlaps(SCREEN_BOUNDS))
        {
            b.update();
        }
        else
        {
            b.alive = false;
        }
    }
}



** now we can clean up our ammo display:

    int bulletsLeft = 0;

...

        if (! b.alive)
        {
            b.x = kBulletW * bulletsLeft++;
            b.y = height - kBulletH;
        }



** that's a lot of bullets, so let's speed them up and limit it to 5

final int kBulletCount = 3;

// let's add this while we're at it:
final float kBulletSpeed = -3.75;


and in Bullet:

    float dy = 0;
    float dx = 0;
        dy = kBulletSpeed;

** and:

int mBulletsLeft = kBulletCount;

void mousePressed()
{
    if (mBulletsLeft > 0)


// in update, after the loop:
    mBulletsLeft = bulletsLeft;



** now let's fix collisions

our collision code wound up in render() which is probably the wrong place.

i put it there because of these fill calls, but now we have a better option.

we can check for collisions with a bullet and then set an alive flag.

this way we can draw the enemies exploding later, and have bullets pass through the anamation.

so... that means we need to add the alive flag from bullet up into a superclass.

in fact, let's actually make a new superclass for all our game objects.

** GameObject

we'll put it above rectangle, so:

copy and paste Rectangle

change the class and constructor name to GameObject

add:
    boolean alive = true;
    float dx = 0;
    float dy = 0;



make render() empty

add:

    public void update()
    {
    }



in Bullet, remove the variables but add to the constructor:

alive = false;

now all of our objects can be alive or dead, and we can:

**  separate the overlap stuff from the render stuff.

[scroll to the overlap logic]


copy the  INSIDE part of the loop (the j stuff only)
 update()... right BEFORE "if (! b.alive) {}"

scroll back down and replace the outer loop contents with:

        fill(mSquares[i].alive ? #FFFFFF : #CCCCCC);
        mSquares[i].render();


[scroll back up]

we actually don't care about the squares overlapping anymore
and we don't care if bullets overlap each other
we only care about bullets overlapping with the squares

we're already in a loop that goes through the bullets,
so we can just test this one bullet against b

remove the i!=j

        for (int j = 0; j < kSquareCount; ++j)
        {
            Square sq = mSquares[j];
            if (sq.alive && b.overlaps(sq))
            {
                sq.alive = false;
                b.alive = false;
            }
        }

we don't need to do this loop if the bullet is dead

if (b.alive)
...
else

** and now we have something that's starting to feel a bit like space invaders!

** That's all for this video.
A lot of what we've done up to this point is really
kind of universal to any game.

So in the next video, we're going to take a step back
and see if we can separate out the generic parts into
a reusable framework.

Seeya then!


* part 3 lecture : A Game Sketch Library
** setup
- BulletDemo open in eclipse on left but AS A JAVA FILE
- RefactorDemo open in eclipse on right as a PDE file
- both open in WinMerge
- VPP open to GameSketchLib class diagram
- Illustrator open to the sprite sheet
- GameSketchLib open in processing (with tabs)
- have last week's image folder handy
- github page open in chrome
** RefactoredDemo
*** show the demo
refactoring is about removing duplication and improving the design.
only thing visibly different is that I added a menu
but under the hood all kinds of things changed
*** in fact, i kind of got carried away.
I wound up turning this refactoring exercise into a complete game engine.
*** show GameSketchLib at github
[ show source/GameSketchLib directory ]

You can kind of see there's a lot there, some of it's new,
but most of it is just cleaned up and redesigned versions
of ideas we've already seen.

Anyway, we'd be here forever if I tried to explain every line,
so I'm just going to give you the highlights.

*** By the way: all the sketches and the course materials are in here
[show top level README with the table]

Lecture notes and demos are under the course directory.

[show week 02 directory]

[show the BulletDemo source] what we did yesterday

[show week02.org]
[search for >>> ]

>>> Here's the script for what I'm saying now. :) <<<

Anyway... Back to our story. 
Let's take a look at what changed.

** Going to use a couple tools to show the changes
*** WinMerge
just shows the differences between any two files
I put old on the left, new on the right.

Here you can see there's a bunch of gold on the right, because
I moved a lot of the reusable stuff into new classes that aren't
part of the main code.

Then most of the sketch variables and the setup code is gone,
because I've moved all that into a class of its own too.

Then there are just lots of little changes. If you're really
curious, I kept a log of what I did. It's in the git repository
under "refactoring.org".

*** Eclipse
has a very basic processing mode
But it's a very solid java IDE.
Since processing code is ALMOST java, we can use it to navigate.
[Stick the whole thing in Browse.java in Eclipse]

** So: The first thing I did was create GameGroup
*** GameGroup takes the place of GameObject[]
so mBullets[] and mSquares[] : now they're GameGroups
*** Once we do that, we have a place to encapsulate a bunch of common tasks that deal with groups
**** example: in BulletDemo::update, we loop through all the squares and bullets and see if they overlap
**** but overlapping two groups is very very common
**** so we can move that up into GameGroup.overlaps
**** other examples:
***** BulletDemo::render() had two loops
****** now we just have two calls to Group.render()
****** i moved the color switching stuff up into rectangle
****** [show GameGroup.render]
***** we can also do GameGroup.update() to update all members
****** That means you can control which groups are updated or rendered first,
or hide an entire group at once.
***** Also a good place for common queries
****** last time we had nextBullet()
****** firstDead
we'll use this again to remove dead aliens in the next video
****** firstAlive
****** I'll probably add a lot more as we go along.

** Let's talk about GameStates
*** Gamestates are just top-level GameGroups
[point out the old render again]
[show how it maps to the new render]
*** so your MenuState might be a GameGroup with a bunch of text objects
[show TitleState and PlayState] - we'll look at them again in a minute
and your PlayState would have your game objects
but they're both just groups of objects that need to be updated and rendered
Actually, GameState does a litle bit more.

*** Show the base GameState class
**** create is just a placeholder for you to add your stuff
**** render draws a background
**** it also has the empty event handlers
***** these may go away
***** i'll show you a universal keyboard handler in a bit
***** but the basic idea is the same:
**** the top level event handlers just dispatch to Game
***** [show top level draw() at hte bottom]
***** Game is always the same object (Singleton)
***** Game dispatches to the current state, which can change at any time

*** Show Game
**** Singleton: You don't use the class, just the one instance.
**** init and switchState are the interface
**** init takes the place of a constructor
it creates a Bounds object so we can test if things are offscreen
and then calls switchState on whatever you passed in.
**** switchState sets the state

*** Show TitleState
**** Just overrides render()
**** Not a very good example, but I didn't have GameText objects.
*** Show MenuState from GameSketchLib
**** GameText is just another GameObject, so you can add it.
**** Then you don't even need a render() - it's all generic.
**** Show again: it draws the background, then everything in the group.
**** [Run GameSketchLib so you can see it]
*** Back to PlayState from the RefactorDemo
**** all the top level variables are inside the class
**** create() takes the place of setup()
**** our top level update() is now just the update method
**** and our top level mousePressed is now just the mousePressed() method
**** PlayState and TitleState both have mousePressed() but only one gets called
because the main mousePressed() calls Game.state.mousePressed()
and there's only one Game.state at a time.
**** The only other real difference is I added a check for killing all the squares:
if firstAlive() == null
that means there are no living invaders, so you win.

** That's pretty much it for RefactorDemo, but I didn't stop there
*** show the uml diagram
**** This is a UML class diagram for GameSketchLib
***** The arrows indicate subclassing.
***** GameBounds is still at the top, etc.
***** the gray ones are all new since RefactorDemo
***** We'll look at each of them in a minute.
***** But first:
**** This definitely isn't perfect
***** May change as the library evolves.
***** GameGroup doesn't really need GameBounds
**** I was sort of emulating Flixel
***** [show flixel uml diagram]
***** FlxObject has Bounds stuff
***** FlxObject and FlxGroup subclass FlxBasic
***** But you can see state is a group, sprite is an FlxObject
***** Our Game singleton is a cross between FlxGame and FlxG.
***** Really solid library, and I may steal even more later. :)
**** Let's look at the new classes
** GameMath
*** only one method so far, which I stole from XNA.
*** > show clamp
** GameText
*** We already saw this in the MenuState
*** Just an object that draws text.
*** Weird processing-js bug, but don't worry about it.
*** Just text at a coordinate.
*** Fonts aren't in GameText yet, BUT:
**** > show Game.init
**** processing-js uses truetype via the browser
**** processing uses vlw files
**** > tools / create font 
**** CONFIG_JVM is a boolean
***** > explain what the ? : does
***** wanted to run same code in either environment
***** made this up so code could handle either case
***** (may be a better way, but I couldn't find it)
***** magic is in GameSketchLib.pde
javascript runtime makes an empty object look like this
in java, the toString() returns a string with a memory address in hex
so I just set a boolean based on that string.
the other lines are just different ways to write it
** GameKeys
*** generalized version of what we did last week
*** that one only handled the WASD/arrow keys
*** this handles everything
*** instead of fiddling bits, we just have a hashmap full of booleans
**** like a filing cabinet
**** look things up by an identifier (key)
**** keys are unique
**** here the keys are characters and the numeric keyCodes
**** > show example at the bottom
*** > briefly mention the keyboard bug from last week
**** works in processing but not in processing-js
**** in short, you can't use CODED as a case in a switch statement
**** keyboard_tests directory has details
**** i submitted a bug report
**** this code works around the problem

** GameSheet
*** last week, every image was separate.
> show last week's images
*** we hadn't talked about arrays or loops or classes
*** now it's pretty easy
*** uses the same CONFIG_PJS trick for the "data" directory.
*** constructor takes an imagename and a grid size and builds a list of squares
> show our sprite sheet in illustrator
note the 50 x 50 grid - all the same size
frame numbers start at 0 in upper left
*** you can ask it for a single frame or an array
*** ... which will come in handy, since next up is sprites
** GameSprite
*** Just a GameObject that shows an image
*** two constructors
**** array of images
**** still image
just for convenience
turns it into an array inside
*** both call sizeToFrame
**** which updates the bounds
**** xOffset and yOffset 
sprites can rotate
this just figures out the center
which we'll see in the next video
*** update() does flipbook-style animation 
**** just cycles through the frame every tick
**** has its own framerate from the timer
we'll look at GameTimer in a second
**** the ++ increments the frame and then % wraps around
**** turn off flipbook with .animated 
might not want to cycle even though you have multiple frames
example: robots last week only change frame to match direction
*** we'll see randomize tomorrow
*** render does rotation magic.
we don't need to worry about it.
** Last but not Least : GameTimer
*** > jump to update and highlight Game.frameMillis
**** how many milliseconds have passed since the last update
**** > might as well show Game.update
*** GameTimer just makes that more usable
we saw it for animation
also use it to schedule anything
can have more than one
two things at different intervals ? two gametimers
in fact, each sprite's animation Timer is separate
*** Here's how to use it
> show doc comment
GameTimer timer = new GameTimer(number * SECONDS);
then in your update, call timer.update() and check for ready
(we just saw that in GameSprite)
*** change speed any time with setTicksPerSecond()
or just set millisPerTick directly.
** Okay, that's the tour!
Next video we're going to use all this to make our game!
If you want to play with it:
> show the live link in the browser


* Part 4: InvaderSketch
** setup
have completed InvaderSketch code open for copy/paste
** > show InvaderSketch
last time we walked through GameSketchLib
now we're going to use it to build this!
** > set up a new game
*** > run source.pde
*** > BaseGameSketch open/save as
*** > MenuState: change click to press enter
** set up our groups
*** > add the member variables
*** > add groups to the state at bottom of create()
**** they're empty but that doesn't hurt anything
** > create HeroSprite class and move him
*** > goE/goW/clamp to move
*** spacebar to shoot
**** Bullet class is same as before except two things:
***** first, it's a sprite instead of a rectangle
uses getFrames but not Animated
we'll see that again when we do the shields
***** second, slightly different collision detection
trueBounds
gets reset in update()
kind of a hack, but it'll work for now

also, other.hurt() instead of other.alive = false

**** USING the bullets is almost exactly the same

class Bullet extends GameSprite

final int kBulletCount = 3;
final float kBulletSpeed = -3.75;
int mBulletsLeft = kBulletCount;

void createBullets()
void updateHeroBullets()

*** > play game : move and shoot
** > Add the aliens
*** > Use this version to demo flipbook animation
class ShipInvader extends GameSprite
{
    ShipInvader(int x, int y)
    {
        super(x, y, SHEET.getFrame(1));
    }    
}


class SpinInvader extends GameSprite
{
    SpinInvader(int x, int y)
    {
        super(x, y, SHEET.getFrames(new int[] { 2, 3 }));
    }
}

class JellInvader extends GameSprite
{
    JellInvader(int x, int y)
    {
        super(x, y, SHEET.getFrames(new int[] { 8, 9, 10, 11 }));
    }
}
*** > paste in the nested create loop
just a couple nested loops
same thing we did with squares last time

except we added a switch statement

also adding them to a group as we go
notice the mShipInvaders distinct from mInvaders
add them to TWO groups because we'll pick one randomly to shoot

*** > play the game : enemies should die
*** > add movement animations
**** paste in JellInvader.update and yDrift
**** paste in SpinInvader.update and yDelta
> show how the rotation stuff works
turn on DEBUG
note: rotates around center
sprite's x and y is still the upper left corner
*** > show what randomize() does
*** > paste in the for movement randomization 

** > make the aliens move
*** > paste updateInvaders()
**** comment out the game over check
**** > run to show what it does
**** let's see how it works
**** removeDead:
mInvaders.removeDead is just a tiny optimization
mShipInvaders.removeDead is important, though, since they'll shoot back
**** real quick: something new in GameGroup.removeDead
... a while loop!
don't want to use a for loop if you're changing the arraylist
true is always true so it goes on forever
but our old friend break is here too.
break jumps to the end of loops too.
**** okay, back to updateInvaders()
*** We're using a GamTimer to control the animation
we saw GameTimer yesterday
our spin and up/down animations don't really need accurate timing
but this one matters, because game over if they reach the bottom

*** other than the timer, pretty much same as the other movement animations
in fact: may end up moving this repeating code into a GameTween class
*** anyway: here the fleet moves 2px every tenth of a second.
*** moves down every time it hits the wall

** enemy fire
*** > paste enemyFire() , add to update(), and run it
*** another use for randomize
**** before we just wanted them to be out of sync
**** here want to vary the time between shots
**** random, but make it about every 2 seconds on average
***** so set it to 4 seconds
***** half the time it'll be between 0 and 2s
***** half the time it'll be between 2 and 4 seconds
***** so 2s is right in the middle
**** true parameter makes timer ready immediately
that randomizes the first shot
otherwise, since we don't call random until the timer is ready
the first shot would always take the full 4 seconds
**** but wait a bit so the player can warm up

*** bullet kills hero, so...
**** > paste in GameOverState
Basically same as MenuState
Different Text
Goes to menustate
**** > paste in Hero.onDeath()
**** > run it. catch a bullet. die.
*** two other end states:
**** first, you can kill al the invaders
***** > paste checkForWin line in update
***** > paste WinState
just extends GameOverState with different text
**** final end state is if alien reaches the ground
***** > uncomment that in updateInvaders
***** it works, but we won't sit around and watch to make sure

** Last Step: add shields
*** > paste in Shield
*** > show the frames in illustrator
*** we just override hurt() to make it happen
*** > add updateShields() to update()

