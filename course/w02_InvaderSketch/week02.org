
* Part 1: Overlap Detection
** setup
*** emacs: assignments.org open in emacs
*** sketchpad: sketchbots running
*** processing: InvaderSketch
*** processing: OverlapDemo ready
*** eclipse: OverlapDemo in Browse.java
** Recap:
*** Week 2 of Newbie Game Dev Course using Processing
**** Loosely follows SquashMonster's UReddit Game Dev Course
**** But really it's for anyone who wants to make games
*** Last week we got a sprite moving with the WASD keys
**** > show sketchbots
*** This week...
**** > show InvaderSketch
**** ... We build a Space Invaders Clone!
**** > back to assignments
**** It's a big task, but we'll break it down.
**** This week's lesson will have four parts.
***** Today we're just going to build this:
> show OverlapDemo

You can drag these squares around
they turn gray when they overlap.

Pretty simple stuff, but we'll use this
exact same logic to track our bullets
in the game

***** along the way we'll talk about
classes, loops, and arrays
which are some pretty basic tools
that we didn't have last week

**** Tomorrow in part 2
make some bullets to shoot these squares
**** Wednesday in part 3
reusable game library called GameSketchLib
**** Thurdsay we'll build the game
*** Let's get started!

** OverlapDemo: Clickable Square
*** let's draw some squares
**** > brand new sketch
**** > add setup() and size(300, 300)
**** going to copy and paste a lot
so you don't have to watch me type everything
**** > one square with rect
**** > run
**** > copy+pase two more
**** > manually add 50 and 100 to x
*** computer can do this for us
**** > paste simple for loop
**** > run it
**** > explain each part
**** > the name doesn't matter. i is traditional.
*** loops can be nested
**** just means one inside the other
**** j is traditional
***** but also x and y
***** or more meaningful names if it's important
**** > run it
*** next!
**** want to move these around with the mouse
**** but that's too big of a step
**** let's just go back to one square
*** make a square change colors when we click
**** > clear setup except for size()
**** > color mSquareColor
**** > add draw() with fill(mSquareColor) and rect()
**** > change mSquareColor to random collor in mousePressed
**** > but not what we want
*** but now we only want it to change color when we click it
**** processing gives us variables called mouseX and mouseY
**** we need to see if they're inside the square or not.
***** mouseX just needs to be between the left and right edges
***** mouseY needs to be between the top and bottom
***** like so:
  if (( x <= mouseX ) && ( mouseX <= (x + w) ) &&
      ( y <= mouseY ) && ( mouseY <= (y + h) ))
  {
  }
**** > explain how this code is what we just said
**** > run it 
** OverlapDemo: Classes and Arrays
*** That's great for one square but we're making nine of them
**** > put the nested loop back in setup
**** we don't want to create variables like
x1 x2 x3 all the way to x9
**** even if we did that, what happens when we have three hundred boxes?
**** We can't just make twelve hundred variables
**** there are two general approaches to this problem
**** let's draw a table to illustrate what these loops produce

| i | j |   x |   y |  w |  h |
|---+---+-----+-----+----+----|
| 0 | 0 |  50 |  50 | 25 | 25 |
| 0 | 1 |  50 | 125 | 25 | 25 |
| 0 | 2 |  50 | 200 | 25 | 25 |
| 1 | 0 | 125 |  50 | 25 | 25 |
| 1 | 1 | 125 | 125 | 25 | 25 |
| 1 | 2 | 125 | 200 | 25 | 25 |
| 2 | 0 | 200 |  50 | 25 | 25 |
| 2 | 1 | 200 | 125 | 25 | 25 |
| 2 | 2 | 200 | 200 | 25 | 25 |


**** i was outermost so i and x stay constant as j changes
**** then i changes and j starts over
**** here's another column

| i | j | i * 3 + j |   x |   y |  w |  h |
|---+---+-----------+-----+-----+----+----|
| 0 | 0 |         0 |  50 |  50 | 25 | 25 |
| 0 | 1 |         1 |  50 | 125 | 25 | 25 |
| 0 | 2 |         2 |  50 | 200 | 25 | 25 |
| 1 | 0 |         3 | 125 |  50 | 25 | 25 |
| 1 | 1 |         4 | 125 | 125 | 25 | 25 |
| 1 | 2 |         5 | 125 | 200 | 25 | 25 |
| 2 | 0 |         6 | 200 |  50 | 25 | 25 |
| 2 | 1 |         7 | 200 | 125 | 25 | 25 |
| 2 | 2 |         8 | 200 | 200 | 25 | 25 |

**** the 3 is there because j loops through 3 values
**** the squares are generated in that order 
**** if we kept some kind of list
**** we could refer to them by their position in the list
**** > type this for them:

squares[0];
squares[3];

// or:

for (int i = 0; i < squares.length; ++i)
{
    doSomethingWith(squares[i]);
}


**** Well, in fact programming languages give us this.
**** List, Array, ArrayList, etc.
**** In processing we already know we can make an int:
int i = 5;
**** but we can also make an array of ints:
int[] i = new int[] { 0, 1, 2, 3, 4 };
**** we can make an array of anything:
PImage[] images = new PImage[5];
images[0] = loadImage(...);
**** we'll use that one for storing frames in an animation later
**** we can even do this:

Square[] squares = new Square[9];

**** which is what we want
**** but what is Square?
**** well if arrays represent the vertical part of our table
**** classes represent the horizontal part
**** it's a collection of fields that work together
**** x, y, w, h make a rectangle
**** w and h are the same so they make a square
**** we can use classes to bundle a bunch of variables into one object
**** We could call our class Rectagle 
**** but I'm going to call it Bounds 
because we're using it to represent the boundaries of our objects
which may or may not look like rectangles on the screen
**** > paste in Bounds(x,y,w,h) constructor
**** > paste in Square extends Bounds (x,y,size) with render
**** > change our loop to make squares and add to array
**** > add a loop to draw them in draw
*** as you can see from this render() method
**** classes are more than just data
**** they have behavior too.
**** we can teach them to handle their own clicks
> add loop inside mousePressed {  if sq.containsPoint() sq.color ... }
> paste in containspoint(x, y) and x2/y2
> run to show them changing colors on click
** OverlapDemo: drag and drop
**** dragging is pretty easy
Square mInHand = null;
> change the color line to mInHand
> explain break inside the for loop
> mouseReleased;
> mouseDragged without mXoff
> run it, point out the jump when you pick up
> fix with mXOff
**** overlap checking has two parts
***** first, we add a method to Bounds
****** so a single Bounds can tell if it overlaps another
****** > paste in overlaps
***** and now we have to test all the combinations
> make sure j = 0 in draw
> paste in draw

Another nested loop does the job.

> run it

*** so that's what we wanted, but hold on a minute.

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|---+---+---+---+---+---+---+---+---+---|
| 0 |   |   |   |   |   |   |   |   |   |
| 1 |   |   |   |   |   |   |   |   |   |
| 2 |   |   |   |   |   |   |   |   |   |
| 3 |   |   |   |   |   |   |   |   |   |
| 4 |   |   |   |   |   |   |   |   |   |
| 5 |   |   |   |   |   |   |   |   |   |
| 6 |   |   |   |   |   |   |   |   |   |
| 7 |   |   |   |   |   |   |   |   |   |
| 8 |   |   |   |   |   |   |   |   |   |


So that's 9 x 9 or 81 checks (remember we start at 0) If we start
adding objects, that table is going to get even bigger. It's always going to be the square of however many objects we have.

Actually we could cut out nine tests here, because we
don't need to check an object against itself.


|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|---+---+---+---+---+---+---+---+---+---|
| 0 | . |   |   |   |   |   |   |   |   |
| 1 |   | . |   |   |   |   |   |   |   |
| 2 |   |   | . |   |   |   |   |   |   |
| 3 |   |   |   | . |   |   |   |   |   |
| 4 |   |   |   |   | . |   |   |   |   |
| 5 |   |   |   |   |   | . |   |   |   |
| 6 |   |   |   |   |   |   | . |   |   |
| 7 |   |   |   |   |   |   |   | . |   |
| 8 |   |   |   |   |   |   |   |   | . |


We can do that by changing this line:

  if (mSquares[i].overlaps(mSquares[j]))
  if (i != j && mSquares[i].overlaps(mSquares[j]))

The && symbol short circuits so the right side is never evaluated.

We can also cut out the top half because if square[0] overlaps
square[1], square[1] also overlaps square[0]


|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
|---+---+---+---+---+---+---+---+---+---|
| 0 | . | . | . | . | . | . | . | . | . |
| 1 |   | . | . | . | . | . | . | . | . |
| 2 |   |   | . | . | . | . | . | . | . |
| 3 |   |   |   | . | . | . | . | . | . |
| 4 |   |   |   |   | . | . | . | . | . |
| 5 |   |   |   |   |   | . | . | . | . |
| 6 |   |   |   |   |   |   | . | . | . |
| 7 |   |   |   |   |   |   |   | . | . |
| 8 |   |   |   |   |   |   |   |   | . |

That brings us down to 36 checks.

To do that
> start j at i + 1

and now we the i vs j check is redundant
> remove i != j 




* Part 2: Bullets
** 2a. BulletDemo overview
*** setup:
- visual paradigm: BulletDemo.vpp  [on overlap page]
- sketch invaders running
- OverlapDemoLive running
- GameStateDemo running
- eclipse: Browse.java empty, OverlapDemoLive open

*** quick recap/preview
we're making sketch invaders (show)
so far we have overlap detection (show)
in this episode: fire with mouse to shoot at frame-animated invaders
*** overlapdemo bird's eye view
**** > show Overlap.pde in eclipse
***** Eclipse is an IDE with a processing plugin.
***** It's still pretty early in development.
***** Really good for java, though.
***** In fact, here's a trick:
**** > paste code into Browse.java
***** can't run it here
***** but can see the structure
****** Bounds
****** Square
****** top level processing methods
**** another way to visualize the structure
***** > show OverlapDemo in vpp
***** this is a UML class diagram
***** unified modeling language
***** huge spec with all kinds of standard diagrams
***** we're just going to look at class diagrams for now
***** so here we have our two classes
****** Bounds
******* all the methods it has
****** Square
******* inherits all that (the arrow)
******* and adds fillColor
****** the other top-level methods like draw and mousePressed are gone
******* they actually are part of a class 
******* everything is really inside class OverlapDemo 
******* but processing hides that, and so will we

**** Here's what we're building today
***** > show BulletDemo tab
***** the two white ones are like yesterday
****** GameObject is just bounds renamed
******* Added one method, onOverlap. It's just a placeholder.
****** GameSquare is just Square
***** We'll move Square's drawing code into GameRect
****** GameRect is just a rectangle
****** That way we can share the drawing code
****** even though Bullets aren't square.
***** GameGroup
****** We used arrays last time
****** GameGroup is like an array on steroids
****** In particular, it's a class so we can 
****** add all kinds of behavior to it, like:
******* overlap()
******* firstDead
******* firstAlive
***** GameBasic
****** Just a nice top level class.
****** All these other objects have their own way to update and render themselves
******* GameObject is invisible, like Bounds was yesterday.
******* GameRect draws a rectangle, but I added liveColor and deadColor
******* GameGroup renders itself by rendering all its members
*** That's the plan for now!
**** Later today, we'll come back and look at the last diagram here.
**** So stay tuned to the playlist!
**** In the next video, we'll actually implement this code.
We're actually write the code for this.

** 2b. GameObject and GameGroup
*** setup
- OverlapDemoLive open in studio sketchpad
http://studio.sketchpad.cc/sp/pad/view/ro.96IuVs0RtADtP/latest
- eclipse: have GameSketchLibDemo ready
- have GameBasic diagram open
- have 

- save as BulletDemoLive

*** factor out GameObject from yesterday's code
**** > run OverlapDemoLive on sketchpad
**** Link is below the video. Feel free to click clone and modify 
**** I'm going to use the processing IDE
**** but you can follow along in another browser window
**** we'll keep the classes and draw
**** but we don't need our old mouse stuff
**** > delete mouseDragged and mouseReleased
**** > leave mousepressed, but make it empty

void mousePressed()
{
    // TODO : fire new Bullet(mouseX, mouseY);
}

**** what is a Bullet?
***** > see UML
***** > write code
    class Bullet extends GameRect
    {
        Bullet(float x, float y)
        {
            super(x, y, 10, 20);
        }
    }
    
***** why not GameBullet?
****** everything starting with game is going into a library
****** bullet isn't quite generic enough.

**** what is a GameRect?
***** well, it's some intermediate form between GameObject and GameSquare
**** GameObject is just a new name for Bounds
***** > rename it
***** > rename constructor
***** > we'll worry about GameBasic later
**** Now we can make GameRect
***** > rename Square to GameSquare
***** > rename constructor
***** > class GameRect extends GameObject
***** > pull up render() and fillColor from GameSquare
**** > make sure everything runs
***** we deleted themouse stuff, but should be 9 squares
*** Let's make some bullets
***** > add kBulletW/H right above Bullet class
final int kBulletW = 10;
final int kBulletH = 20;
***** update Bullet constructor
super(x, y, kBulletW, kBulletH);
***** what are these for?
****** we can always make a bullet and check its .w and .h
****** but you'll see in a minute we want the width and height
****** before we actually make the instance
****** really want this to be static in the Bullet class
****** but processing doesn't like that.

***** let's start with 10 bullets.
kBulletCount = 10;
Bullet[] mBullets = new Bullet[kBulletCount];

for (int i = 0; i < kBulletCount; ++i)
{
    mBullets[i] = new Bullet(kBulletW * i, height - kBulletH);
}
***** see why we needed the width and height first?
***** we're placing them in a little line in the bottom left
***** now to draw them
let's ignore the collision detection code up here for the time being,
and just draw our bullets. We'll make them gold.

    fill(#FFCC33);
    for (int i = 0; i < kBulletCount; ++i)
    {
        mBullets[i].render();
    }
***** > run it 
*** notice the duplicate work
**** > extract the square rendering to make it explicit
**** these two loops are exactly the same
**** Yesterday we started to see how classes can eliminate duplication.
***** Rather than having duplicate variables and if statements 
***** to check each square for a click
***** we made the Bounds class
***** (now gameobject)
***** and taught it how to tell whether it contained a point
**** Wouldn't it be nice if we could teach these arrays to loop through and call render?
***** well, we can't add methods to an array
***** but we can make something LIKE an array
***** that's what GameGroup is all about
*** > GameGroup extends GameBasic
**** > paste in GameBasic
***** pretty much exactly like the diagram
***** doesn't have any behavior
***** just a placeholder
***** doesn't even need a constructor
***** DOES guarantee that we can call these methods on all our objects
***** and they all have any of these states
***** GameGroup might not need alive but it needs the others
****** see, we want GameGroup to contain anything that's a GameBasic
****** GameGroup itself is a GameBasic
****** so we'll be able to put one GameGroup inside another
****** So you could have one big group with smaller groups inside
****** then you could hide or freeze whole groups at once 
****** just by setting the value on the group.
**** > make GameObject extend GameBasic
*** GameGroup methods:
**** > paste in: members, constructor, get, put, set, size, remove, size
**** This is pretty much like an array.
***** instead of brackets we have get and put
****** set is just another word for put
***** instead of length, we have size()
***** but notice there's no size when we create it
**** That's because instead of an array, we use ArrayList
***** Arrays are fixed size
***** ArrayLists can grow and shrink.
***** > paste add
***** > paste remove
*** Replace our arrays with Groups
**** > mBullets
**** > mSquares
**** > use add() in setup()
**** > in draw, replace the loops with render()
**** > just comment out the overlap detection
***** the squares don't move anymore but we'll keep this around
***** for reference for a little while
**** > run it again
*** next video: fire the bullets
** 2c. Firing our Bullets
*** setup
- work in progress running
*** > run it.
*** so let's fire a bullet
**** first we have to decide which bullet to fire
**** let's take the first one for now.

void mousePressed()
{
    Bullet b = mBullets.get(0)
    // place it at the mouse x
    b.x = mouseX;
    // but fire from below
    b.y = height - kBulletH * 2;
}

**** > run
**** same bullet each time
*** now let's make it move.
**** two parts
**** part one is to make it move
***** > add floats dx and dy to GameObject
****** d is for delta
****** delta x means change in x
****** if you take a physics or calculus class you'll see deltas all over the 
***** we COULD add it to Bullet, but lots of things can move
***** > write GameObject.update()
    void update()
    {
        y += dy;
        x += dx;
    }
***** Now in bullet constructor we can say

    kBulletSpeed = 1;
    this.dy = -kBulletSpeed;
***** but update isn't being called anywhere yet
****** > put update() at the top of the draw for both groups
***** > run it
**** so part 2 is making sure only the bullets we've actually fired move
***** > set **ACTIVE** to false in Bullet constructor # NOT ALIVE!
***** > remember, the update method in GameGroup checks for alive before calling update.
***** now we need to make it active when we fire it. 
***** > let's make a new method for that.

    void fire(float x, float y)
    {
        this.x = x;
        this.y = y;
        this.active = true;
    }

***** and now we update mousePressed() to use the new interface:

void mousePressed()
{
    Bullet b = mBullets.get(0);
    b.fire(mouseX, height - kBulletH * 2);
}

***** > run it
*** our bullet jumps back down every time we click
*** instead of the first bullet, we should get the first inactive one
**** > paste in firstInactive
***** > explain "return"
***** > explain return null
**** > call firstInactive to pick bullet
**** > check for null
**** > run it
**** > use all the bullets
*** out of bullets. that'll be a pretty short game!
**** let's put them back in our ammo clip after they leave the top of the screen
**** how do we know if a bullet is still on the screen or not?
**** well, we learned how to do that yesterday
***** > make SCREEN_BOUNDS
GameObject SCREEN_BOUNDS;
SCREEN_BOUNDS = new GameObject(0, 0, width, height);
***** > deactivate the bullet in draw()
if (! bullet.overlaps(SCREEN_BOUNDS))
{
    bullet.active = false;
}
***** we could also put this in Bullet.update
****** that's kind of a style choice.
****** anything just about the object goes in the class
****** but this is really more about the interactions between the bullet and this screen bounds object
****** to me, interactions go into the main update loop
****** which right now is called draw, but let's make it explicit real quick
***** > extract update() and render() from draw()
***** notice how the whole game has the same structure as GameBasic?
***** that'll come in handy pretty soon.
***** > run it
***** yay, plenty of ammo now. but let's actually fill up the ammo clip

*** let's clean up the ammo display
**** we want to just want to tack each one on the end as we reclaim it
**** but we also want them to shift left
**** it's easiest to just redraw the whole thing
**** > paste the bullet cleanup loop over bullets.update()
**** see, we need to track the bulletsLeft count across all the updates
***** we could declare a top level variable and update it in Bullet.update
***** but that gets really messy
***** again, for me, logic that deals with multiple objcets goes in the game's update
***** even if they're all the same class
**** > walk through the loop.
**** > run it
*** that's a lot of bullets, so let's speed them up and limit it to 5
final int kBulletCount = 3;
final float kBulletSpeed = 3.75;


*** finally, let's hit something
**** here's our old overlap detection from last time
**** let's review how it worked
***** we had a loop to go through the array
***** and another loop to go through the same array
***** and we just checked every pair for overlaps
**** well, now we want to compare two separate groups - bullets and squares
***** we can just change one of the loops to use the other group
***** but we're going to do this A LOT
***** so we can just teach GameGroup to do it
***** > delete the old code
***** > paste in GameGroup.overlap
***** you can see it's the same logic
****** loop through one group
****** loop through the other group
****** make sure they're not the same object
****** but it respects .active and .exists
****** and instead of changing the color right there, we call a.onOverlap(b)
****** onOverlap only applies to GameObjects
******* that's why we cast with parentheses
******* otherwise we'd have a GameBasic which doesn't have onOverlap
******* so we have a bug with nested groups
******* i'm trying to emulate flixel here,
******* so i'll fix it later to do whatever flixel does
******* we'll talk more about flixel next lesson
******* but for now:
******* just don't call overlap on groups that contain other groups.
****** > make sure void onOverlap(GameObject other) { } is there
***** so now we can use this to kill the squares
****** > update: mBullets.overlap(mSquares);
****** > Bullet.onOverlap
void onOverlap(GameObject other)
{
    this.alive = false;
    other.alive = false;
}
***** one more thing before we can run it
****** GameRect.render
color liveColor = #FFFFFF;
color deadColor = #CCCCCC;
fill(this.alive ? this.liveColor : this.deadColor );
***** > run it
***** > kill ALL the squares
*** this is starting to feel a bit like space invaders!
**** That's all for this video.
**** Next video we'll see how to add a title screen 
**** and how to tell the game to start over after we kill the squares
** 2d. Screenflow with GameState
*** setup
BulletDemoLive running
vpp: open to BulletDemo tab
empty Browse.java in eclipse
*** so here's where we're at:
**** > run BulletDemoLive
**** we have some bullets and we can shoot the squares
**** now we're going to add a title screen 
**** and an option to restart after we kill everybody
*** > paste the code into Browse.java
**** if you recall, everything in our game has an update and a render
**** some things just inherit the default implementations, which do nothing
**** some override them to do other special things
**** but everything uses that same interface.
**** in fact, the main loop of the whole game object just calls those two methods
**** remember (BulletDemo) is itself one big java class
**** and look at render here: we're just calling render on two sub-objects
**** really, BulletDemo as an object looks quite a bit like a GameGroup.
*** what would happen if we made our whole game into a GameGroup?
**** Let's find out!
**** Here's what I propose.
**** > open vpp to GameStateDemo
**** We can create a GameState class that is exactly like GameGroup
***** except it draws a background before it renders
***** and it has methods for everything we're doing with the mouse
*** so then we could make different kinds of states
**** so we could make a menu state
***** and it could contain a bunch of text objects
***** so when it renders, you see words on the screen
***** we could have it say "click here to start the game"
***** and then the mousePressed event, we could switch to the PlayState
**** then in our PlayState we'd have the game
***** render would call the render method on our squares and bullets
***** and update would update the game just like it does now
**** at the very top level
***** we'd start with a variable of type GameState to hold the current state
***** then instead of just calling top-level update() and render() methods
****** the top level draw() would call currentState.update() and currentState.render()
****** and since GameStates would be GameGroups...
****** they would already know how to update and render whatever's inside them
***** the top level mousePressed would the state's mousepressed method
***** the top level mouseReleased would call the state's mouseReleased
*** it turns out this is a pretty handy way to organize a game
*** so we're going to do it!
*** and just so we can package it up nicely 
**** we'll keep the current state 
**** and the state-switching logic
**** in a special container object called Game
*** So that's the plan. Let's do it!
*** First up: GameState
**** > paste GameState
**** the create method here is just a place to do setup stuff
***** it's basically the same as setup for a processing sketch
***** I called it create instead of setup because 
***** i'm trying to make this like the flixel game library for flash
***** and flixel calls it create
**** render just uses GameGroup's render
***** after it clears the screen with the background color
**** we don't need to change update at all, so it just inherits the one from GameGroup
**** and then we add all these empty mouse handlers
***** these might go away
***** i've already done something else with the keyboard methods
****** i generalized the keyboard stuff from last week
****** and now there's a universal keyboard event handler
****** which we'll take a look at later
***** I may do something similar for the mouse
***** but for now we'll just override mousePressed in each state
**** > create empty PlayState
**** > put the game inside it
**** ! setup should only have size(300, 300); and nothing else
**** > run. (should do nothing now)
**** > paste in Game
***** Game isn't really a class, it's an object
****** But it's the only instance of class GameClass we need.
****** In java or actionscript, we'd use a class with the static keyword
****** But processing doesn't like that, so I just did this.
***** The code is pretty straightforward
****** Game.state is the current state
****** Game.bounds is exactly the same as what we called SCREEN_BOUNDS
****** will init() gets called once in setup
****** after that you can use switchState() to change states
****** and it'll call the create method so the state can set itself up.
**** Now we can go back and add the top level methods for processing
***** > paste draw and mouseXXX
***** hopefully no surprises there.
***** everything just delegates to the current state object
***** and now we just pass it our PlayState
***** > do so, and run [ game should run as before ]
**** Now let's add the Menu Screen...
***** > MenuState extends GameState
***** > paste in mousePressed but NOT render
***** > change setup to use MenuState
***** > run [ should see black screen and then click gives us the game]
**** not much of a menu yet
***** That's where GameText comes in
****** > paste GameText
****** basically this just wraps the normal text drawing routines for processing
******* if you notice, there's a line about a default font commented out
******* processing and processing-js handle fonts differently
******* we'll take a closer look at this class next time
****** for now, the important thing is that it's a GameObject 
****** and that means we can add it to a GameGroup or a GameState
****** so let's add some text to our main menu screen
****** > paste MenuState. create()
****** > run
**** last thing. let's make the game start over when we kill all the squares
***** > paste firstAlive() line in update()
***** if there are no living squares go back to the title state
***** except we didn't implement firstAlive yet
***** but it's exactly the same as firstInactive
***** except for the check
***** > copy and paste from firstInactive
***** I really don't like this.
****** In a lot of languages we can pass a function in as a parameter
****** it's called a lambda or an anonymous function
****** but processing is based on java, and java doesn't have lambdas yet
******* apparently, they're finally coming in java 8
******* so maybe processing will get them
****** for now, java has something called anonymous classes
****** but they take almost as much code to write as these loops
****** we might try them at some point, but this will do for now.
***** in any case, people using the GameGroup class only have to call the methods
***** all the ugly repetition is hidden away
**** so now that we have firstAlive...
***** game should start over when we shoot all the squares
***** > run it
**** that's all for today
***** I'll put this code up on studio sketchpad so you can run it right in your browser
***** and make sure there's a link in the video description on youtube.
***** Next time, we'll pack all this GameObject stuff up into a library
***** and we'll start work on the actual Space Invaders GameSketch.
**** thanks for watching
***** if you like these lessons
***** please subscribe to the channel
***** and leave a comment
***** letting me know what you like and don't like about these videos
***** Thanks!
***** See you soon.


* part 3 lecture : A Game Sketch Library
** setup
- BulletDemo open in eclipse on left but AS A JAVA FILE
- RefactorDemo open in eclipse on right as a PDE file
- both open in WinMerge
- VPP open to GameSketchLib class diagram
- Illustrator open to the sprite sheet
- GameSketchLib open in processing (with tabs)
- have last week's image folder handy
- github page open in chrome
** RefactoredDemo
*** show the demo
refactoring is about removing duplication and improving the design.
only thing visibly different is that I added a menu
but under the hood all kinds of things changed
*** in fact, i kind of got carried away.
I wound up turning this refactoring exercise into a complete game engine.
*** show GameSketchLib at github
[ show source/GameSketchLib directory ]

You can kind of see there's a lot there, some of it's new,
but most of it is just cleaned up and redesigned versions
of ideas we've already seen.

Anyway, we'd be here forever if I tried to explain every line,
so I'm just going to give you the highlights.

*** By the way: all the sketches and the course materials are in here
[show top level README with the table]

Lecture notes and demos are under the course directory.

[show week 02 directory]

[show the BulletDemo source] what we did yesterday

[show week02.org]
[search for >>> ]

>>> Here's the script for what I'm saying now. :) <<<

Anyway... Back to our story. 
Let's take a look at what changed.

** Going to use a couple tools to show the changes
*** WinMerge
just shows the differences between any two files
I put old on the left, new on the right.

Here you can see there's a bunch of gold on the right, because
I moved a lot of the reusable stuff into new classes that aren't
part of the main code.

Then most of the sketch variables and the setup code is gone,
because I've moved all that into a class of its own too.

Then there are just lots of little changes. If you're really
curious, I kept a log of what I did. It's in the git repository
under "refactoring.org".

*** Eclipse
has a very basic processing mode
But it's a very solid java IDE.
Since processing code is ALMOST java, we can use it to navigate.
[Stick the whole thing in Browse.java in Eclipse]

** So: The first thing I did was create GameGroup
*** GameGroup takes the place of GameObject[]
so mBullets[] and mSquares[] : now they're GameGroups
*** Once we do that, we have a place to encapsulate a bunch of common tasks that deal with groups
**** example: in BulletDemo::update, we loop through all the squares and bullets and see if they overlap
**** but overlapping two groups is very very common
**** so we can move that up into GameGroup.overlaps
**** other examples:
***** BulletDemo::render() had two loops
****** now we just have two calls to Group.render()
****** i moved the color switching stuff up into rectangle
****** [show GameGroup.render]
***** we can also do GameGroup.update() to update all members
****** That means you can control which groups are updated or rendered first,
or hide an entire group at once.
***** Also a good place for common queries
****** last time we had nextBullet()
****** firstDead
we'll use this again to remove dead aliens in the next video
****** firstAlive
****** I'll probably add a lot more as we go along.

** Let's talk about GameStates
*** Gamestates are just top-level GameGroups
[point out the old render again]
[show how it maps to the new render]
*** so your MenuState might be a GameGroup with a bunch of text objects
[show TitleState and PlayState] - we'll look at them again in a minute
and your PlayState would have your game objects
but they're both just groups of objects that need to be updated and rendered
Actually, GameState does a litle bit more.

*** Show the base GameState class
**** create is just a placeholder for you to add your stuff
**** render draws a background
**** it also has the empty event handlers
***** these may go away
***** i'll show you a universal keyboard handler in a bit
***** but the basic idea is the same:
**** the top level event handlers just dispatch to Game
***** [show top level draw() at hte bottom]
***** Game is always the same object (Singleton)
***** Game dispatches to the current state, which can change at any time

*** Show Game
**** Singleton: You don't use the class, just the one instance.
**** init and switchState are the interface
**** init takes the place of a constructor
it creates a Bounds object so we can test if things are offscreen
and then calls switchState on whatever you passed in.
**** switchState sets the state

*** Show TitleState
**** Just overrides render()
**** Not a very good example, but I didn't have GameText objects.
*** Show MenuState from GameSketchLib
**** GameText is just another GameObject, so you can add it.
**** Then you don't even need a render() - it's all generic.
**** Show again: it draws the background, then everything in the group.
**** [Run GameSketchLib so you can see it]
*** Back to PlayState from the RefactorDemo
**** all the top level variables are inside the class
**** create() takes the place of setup()
**** our top level update() is now just the update method
**** and our top level mousePressed is now just the mousePressed() method
**** PlayState and TitleState both have mousePressed() but only one gets called
because the main mousePressed() calls Game.state.mousePressed()
and there's only one Game.state at a time.
**** The only other real difference is I added a check for killing all the squares:
if firstAlive() == null
that means there are no living invaders, so you win.

** That's pretty much it for RefactorDemo, but I didn't stop there
*** show the uml diagram
**** This is a UML class diagram for GameSketchLib
***** The arrows indicate subclassing.
***** GameBounds is still at the top, etc.
***** the gray ones are all new since RefactorDemo
***** We'll look at each of them in a minute.
***** But first:
**** This definitely isn't perfect
***** May change as the library evolves.
***** GameGroup doesn't really need GameBounds
**** I was sort of emulating Flixel
***** [show flixel uml diagram]
***** FlxObject has Bounds stuff
***** FlxObject and FlxGroup subclass FlxBasic
***** But you can see state is a group, sprite is an FlxObject
***** Our Game singleton is a cross between FlxGame and FlxG.
***** Really solid library, and I may steal even more later. :)
**** Let's look at the new classes
** GameMath
*** only one method so far, which I stole from XNA.
*** > show clamp
** GameText
*** We already saw this in the MenuState
*** Just an object that draws text.
*** Weird processing-js bug, but don't worry about it.
*** Just text at a coordinate.
*** Only one font at the moment, but you can change it
**** > show Game.init
**** processing-js uses truetype via the browser
**** processing uses vlw files
**** > tools / create font 
**** CONFIG_JVM is a boolean
***** > explain what the ? : does
***** wanted to run same code in either environment
***** made this up so code could handle either case
***** (may be a better way, but I couldn't find it)
***** magic is in GameSketchLib.pde
javascript runtime makes an empty object look like this
in java, the toString() returns a string with a memory address in hex
so I just set a boolean based on that string.
the other lines are just different ways to write it
*** Anyway, to change the font, just set defaultFont to something else
*** Next Topic!

** GameKeys
*** generalized version of what we did last week
*** that one only handled the WASD/arrow keys
*** this handles everything
*** instead of fiddling bits, we just have a hashmap full of booleans
**** like a filing cabinet
**** look things up by an identifier (key)
**** keys are unique
**** here the keys are characters and the numeric keyCodes
**** > show example at the bottom
*** > briefly mention the keyboard bug from last week
**** works in processing but not in processing-js
**** in short, you can't use CODED as a case in a switch statement
**** keyboard_tests directory has details
**** i submitted a bug report
**** this code works around the problem

** GameSheet
*** last week, every image was separate.
> show last week's images
*** we hadn't talked about arrays or loops or classes
*** now it's pretty easy
*** uses the same CONFIG_PJS trick for the "data" directory.
*** constructor takes an imagename and a grid size and builds a list of squares
> show our sprite sheet in illustrator
note the 50 x 50 grid - all the same size
frame numbers start at 0 in upper left
*** you can ask it for a single frame or an array
*** ... which will come in handy, since next up is sprites
** GameSprite
*** Just a GameObject that shows an image
*** two constructors
**** array of images
**** still image
just for convenience
turns it into an array inside
*** both call sizeToFrame
**** which updates the bounds
**** xOffset and yOffset 
sprites can rotate
this just figures out the center
which we'll see in the next video
*** update() does flipbook-style animation 
**** just cycles through the frame every tick
**** has its own framerate from the timer
we'll look at GameTimer in a second
**** the ++ increments the frame and then % wraps around
**** turn off flipbook with .animated 
might not want to cycle even though you have multiple frames
example: robots last week only change frame to match direction
*** we'll see randomize tomorrow
*** render does rotation magic.
we don't need to worry about it.
** Last but not Least : GameTimer
*** > jump to update and highlight Game.frameMillis
**** how many milliseconds have passed since the last update
**** > might as well show Game.update
*** GameTimer just makes that more usable
we saw it for animation
also use it to schedule anything
can have more than one
two things at different intervals ? two gametimers
in fact, each sprite's animation Timer is separate
*** Here's how to use it
> show doc comment
GameTimer timer = new GameTimer(number * SECONDS);
then in your update, call timer.update() and check for ready
(we just saw that in GameSprite)
*** change speed any time with setTicksPerSecond()
or just set millisPerTick directly.
** Okay, that's the tour!
Next video we're going to use all this to make our game!
If you want to play with it:
> show the live link in the browser


* Part 4: InvaderSketch
** setup
have completed InvaderSketch code open for copy/paste
** > show InvaderSketch
last time we walked through GameSketchLib
now we're going to use it to build this!
** > set up a new game
*** > run source.pde
*** > BaseGameSketch open/save as
*** > MenuState: change click to press enter
** set up our groups
*** > add the member variables
*** > add groups to the state at bottom of create()
**** they're empty but that doesn't hurt anything
** > create HeroSprite class and move him
*** > goE/goW/clamp to move
*** spacebar to shoot
**** Bullet class is same as before except two things:
***** first, it's a sprite instead of a rectangle
uses getFrames but not Animated
we'll see that again when we do the shields
***** second, slightly different collision detection
trueBounds
gets reset in update()
kind of a hack, but it'll work for now

also, other.hurt() instead of other.alive = false

**** USING the bullets is almost exactly the same

class Bullet extends GameSprite

final int kBulletCount = 3;
final float kBulletSpeed = -3.75;
int mBulletsLeft = kBulletCount;

void createBullets()
void updateHeroBullets()

*** > play game : move and shoot
** > Add the aliens
*** > Use this version to demo flipbook animation
class ShipInvader extends GameSprite
{
    ShipInvader(int x, int y)
    {
        super(x, y, SHEET.getFrame(1));
    }    
}


class SpinInvader extends GameSprite
{
    SpinInvader(int x, int y)
    {
        super(x, y, SHEET.getFrames(new int[] { 2, 3 }));
    }
}

class JellInvader extends GameSprite
{
    JellInvader(int x, int y)
    {
        super(x, y, SHEET.getFrames(new int[] { 8, 9, 10, 11 }));
    }
}
*** > paste in the nested create loop
just a couple nested loops
same thing we did with squares last time

except we added a switch statement

also adding them to a group as we go
notice the mShipInvaders distinct from mInvaders
add them to TWO groups because we'll pick one randomly to shoot

*** > play the game : enemies should die
*** > add movement animations
**** paste in JellInvader.update and yDrift
**** paste in SpinInvader.update and yDelta
> show how the rotation stuff works
turn on DEBUG
note: rotates around center
sprite's x and y is still the upper left corner
*** > show what randomize() does
*** > paste in the for movement randomization 

** > make the aliens move
*** > paste updateInvaders()
**** comment out the game over check
**** > run to show what it does
**** let's see how it works
**** removeDead:
mInvaders.removeDead is just a tiny optimization
mShipInvaders.removeDead is important, though, since they'll shoot back
**** real quick: something new in GameGroup.removeDead
... a while loop!
don't want to use a for loop if you're changing the arraylist
true is always true so it goes on forever
but our old friend break is here too.
break jumps to the end of loops too.
**** okay, back to updateInvaders()
*** We're using a GamTimer to control the animation
we saw GameTimer yesterday
our spin and up/down animations don't really need accurate timing
but this one matters, because game over if they reach the bottom

*** other than the timer, pretty much same as the other movement animations
in fact: may end up moving this repeating code into a GameTween class
*** anyway: here the fleet moves 2px every tenth of a second.
*** moves down every time it hits the wall

** enemy fire
*** > paste enemyFire() , add to update(), and run it
*** another use for randomize
**** before we just wanted them to be out of sync
**** here want to vary the time between shots
**** random, but make it about every 2 seconds on average
***** so set it to 4 seconds
***** half the time it'll be between 0 and 2s
***** half the time it'll be between 2 and 4 seconds
***** so 2s is right in the middle
**** true parameter makes timer ready immediately
that randomizes the first shot
otherwise, since we don't call random until the timer is ready
the first shot would always take the full 4 seconds
**** but wait a bit so the player can warm up

*** bullet kills hero, so...
**** > paste in GameOverState
Basically same as MenuState
Different Text
Goes to menustate
**** > paste in Hero.onDeath()
**** > run it. catch a bullet. die.
*** two other end states:
**** first, you can kill al the invaders
***** > paste checkForWin line in update
***** > paste WinState
just extends GameOverState with different text
**** final end state is if alien reaches the ground
***** > uncomment that in updateInvaders
***** it works, but we won't sit around and watch to make sure

** Last Step: add shields
*** > paste in Shield
*** > show the frames in illustrator
*** we just override hurt() to make it happen
*** > add updateShields() to update()

